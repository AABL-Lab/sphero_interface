#!/usr/bin/env python3
'''
Node to control an arbitrary number of spheros to their goals
@author james.staley625703@tufts.edu
'''

import traceback
from copy import deepcopy
import time, math, random

from numpy import rad2deg
from IPython import embed

import rospy
from rospy import Subscriber
from std_msgs.msg import Float32
from geometry_msgs.msg import Pose2D, PoseWithCovarianceStamped
from sphero_interface.msg import HeadingStamped, SpheroNames, PositionGoal
from tf.transformations import euler_from_quaternion

from utils import pose2d_distance, posewithcovariancestamped_to_pose2d

VERBOSE = True

UPDATE_PERIOD = 0.1 # seconds for control loop
SPEED = 30
GOAL_THRESHOLD = 50 # How far we can be from a goal before its considered achieved
TEST_SQUARE_LEN = 200
LOOP_TRAJECTORY = False

'''
Parent class that handles all subscribers and publishers
'''
class TrajectoryFollowerGroup():
    def __init__(self) -> None:
        rospy.Subscriber("/sphero_names", SpheroNames, self.sphero_names_cb)
        
        self.cmd_publishers = dict()
        self.pose_subscribers = dict() # we dont really need to hold on to these but since they're autogenerated lets keep handles to them
        self.goal_subscribers = dict()
        self.initial_heading_subscribers = dict()

        self.initial_headings = dict()
        self.sphero_poses = dict()
        self.goal_poses = dict()

        # self.goal_pub = rospy.Publisher(sphero_id+"/goal", Pose2D, queue_size=1)

    def sphero_names_cb(self, msg: SpheroNames):
        '''
        Callback for the sphero names message.
        '''
        for name in msg.data:
            if name in self.cmd_publishers: 
                pass
            else:
                self.cmd_publishers[name] = rospy.Publisher(name+"/cmd", HeadingStamped, queue_size=1)
                self.pose_subscribers[name] = rospy.Subscriber(name+"/pose", Pose2D, self.pose_callback, callback_args=name)
                self.goal_subscribers[name] = rospy.Subscriber(name+"/goal", PositionGoal, self.goal_callback, callback_args=name)
                self.initial_heading_subscribers[name] = rospy.Subscriber(name+"/initial_heading", HeadingStamped, self.initial_heading_callback, callback_args=name)

    def pose_callback(self, msg, name): self.sphero_poses[name] = msg
    def goal_callback(self, msg, name): self.goal_poses[name] = msg.goal # TODO: this should either have name as a callback arg or use the name in the messages, not both
    def initial_heading_callback(self, msg, name): self.initial_headings[name] = msg.theta

    def update(self):
        for name, goal in self.goal_poses.items():
            if name not in self.sphero_poses: 
                rospy.logwarn("Goal, but no pose for " + name)
                continue
            elif name not in self.initial_headings:
                rospy.logwarn("Goal, but no initial heading for " + name)
                continue

            cmd = self.cmd_for(self.sphero_poses[name], goal, self.initial_headings[name])
            # cmd = self.cmd_for(self.sphero_poses[name], goal)
            self.cmd_publishers[name].publish(cmd)

    def cmd_for(self, curr_pose: Pose2D, goal_pose: Pose2D, initial_heading=0):
        cmd = HeadingStamped()
        if (pose2d_distance(curr_pose, goal_pose) < GOAL_THRESHOLD):
            pass
        else:
            # Ys need to be flipped because of image coordinate system
            theta_goal = (math.atan2((-1*goal_pose.y) + curr_pose.y, goal_pose.x - curr_pose.x)) # NOTE: afaik we can't reset the sphero's heading through bluetooth
            
            if VERBOSE: rospy.loginfo(f"goal_to_theta {theta_goal:1.2f} th0 {initial_heading:1.2f}")
            # theta_goal = initial_heading - theta_goal


            current_theta_local = curr_pose.theta - initial_heading
            # current_theta_local = curr_pose.theta

            while theta_goal < 0: theta_goal += 2*math.pi
            while theta_goal > 2*math.pi: theta_goal -= 2*math.pi
            while current_theta_local < 0: current_theta_local += 2*math.pi
            while current_theta_local > 2*math.pi: current_theta_local -= 2*math.pi

            diff_theta = abs(theta_goal - current_theta_local)
            if VERBOSE: rospy.loginfo(f"diff_theta {diff_theta:1.2f}")

            cmd.v = SPEED if diff_theta < (math.pi / 4.) else 0 # Only move forward if we're mostly aligned with the goal
            cmd.theta = rad2deg(theta_goal) # correct for offset initial heading in cmd
        
        if VERBOSE: rospy.loginfo(f"current x:{curr_pose.x:1.1f} y:{curr_pose.y:1.1f} theta:{curr_pose.theta:1.1f} goal {goal_pose.x:1.1f} {goal_pose.y:1.1f} {goal_pose.theta:1.1f} cmd {cmd.v:1.1f} {cmd.theta:1.1f}")
        return cmd

'''
Run a group of commanders that creates one sphero for each name on the topic
'''
def main():
    rospy.init_node("trajectory_follower")
    trajectory_follower_group = TrajectoryFollowerGroup()
    rospy.loginfo("Looping...")
    while not (rospy.is_shutdown()):
        trajectory_follower_group.update()
        time.sleep(UPDATE_PERIOD)


if __name__ == "__main__":
    try:
    # main_single_commander():
        main()
    except rospy.ROSInterruptException:
        pass