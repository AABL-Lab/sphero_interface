#!/usr/bin/env python3
'''
Node to control an arbitrary number of spheros to their goals
@author james.staley625703@tufts.edu
'''

import traceback
from copy import deepcopy
import time, math, random

from numpy import rad2deg
from IPython import embed

import rospy
from rospy import Subscriber
from std_msgs.msg import Float32
from geometry_msgs.msg import Pose2D, PoseWithCovarianceStamped
from sphero_interface.msg import HeadingStamped, SpheroNames, PositionGoal
from tf.transformations import euler_from_quaternion

from utils import pose2d_distance

VERBOSE = False

UPDATE_PERIOD = 0.1 # seconds for control loop
SPEED = 30
GOAL_THRESHOLD = 50 # How far we can be from a goal before its considered achieved
TEST_SQUARE_LEN = 200
LOOP_TRAJECTORY = False


    # def trajectory_step(self):
    #     if (self.is_complete()): return

    #     goal_pose = self.path_x_y[self.trajectory_idx]
    #     self.goal_pub.publish(Pose2D(goal_pose.x, goal_pose.y, 0))
    #     distance_to_goal = pose2d_distance(self.pose, goal_pose)
    #     print(f"distance_to_goal {distance_to_goal:1.2f}")
    #     if (distance_to_goal < GOAL_THRESHOLD):
    #         self.trajectory_idx += 1
    #         if (self.trajectory_idx >= len(self.path_x_y)): # done
    #             self.path_complete = True
    #             if (LOOP_TRAJECTORY):
    #                 self.trajectory_idx = 0
    #         else: # new goal
    #             goal_pose = self.path_x_y[self.trajectory_idx]
    #             print(f"new goal {goal_pose.x:1.2f} {goal_pose.y:1.2f}")


    #     if (self.path_complete):
    #         cmd = HeadingStamped()
    #     else:
    #         cmd = self.get_command(self.pose, goal_pose)
    #     # cmd = HeadingStamped()
    #     command_history.append(cmd)
    #     self.pub.publish(cmd)

    # def random_orientation(self):
    #     '''
    #     Randomly orient the sphero
    #     '''
    #     cmd = HeadingStamped()
    #     cmd.v = 10
    #     cmd.theta = random.randint(0, 360)
        
    #     self.pub.publish(cmd)

'''
Parent class that handles all subscribers and publishers
'''
class TrajectoryFollowerGroup():
    def __init__(self) -> None:
        rospy.Subscriber("/sphero_names", SpheroNames, self.sphero_names_cb)
        
        self.cmd_publishers = dict()
        self.pose_subscribers = dict() # we dont really need to hold on to these but since they're autogenerated lets keep handles to them
        self.goal_subscribers = dict()
        self.initial_heading_subscribers = dict()

        self.initial_headings = dict()
        self.sphero_poses = dict()
        self.goal_poses = dict()

        # self.goal_pub = rospy.Publisher(sphero_id+"/goal", Pose2D, queue_size=1)

    def sphero_names_cb(self, msg: SpheroNames):
        '''
        Callback for the sphero names message.
        '''
        for name in msg.data:
            if name in self.cmd_publishers: 
                pass
            else:
                self.cmd_publishers[name] = rospy.Publisher(name+"/cmd", HeadingStamped, queue_size=1)
                self.pose_subscribers[name] = rospy.Subscriber(name+"_ekf/odom_combined", PoseWithCovarianceStamped, self.ekf_callback, callback_args=name)
                self.goal_subscribers[name] = rospy.Subscriber(name+"/goal", PositionGoal, self.goal_cb, callback_args=name)
                self.initial_heading_subscribers[name] = rospy.Subscriber(name+"/initial_heading", HeadingStamped, self.initial_heading_cb, callback_args=name)

    def ekf_callback(self, msg, name): self.sphero_poses[name] = msg
    def goal_callback(self, msg, name): self.goal_poses[name] = msg
    def initial_heading_callback(self, msg, name): self.initial_heading[name] = msg

    def update(self):
        for name, goal in self.goal_poses.items():
            if name not in self.sphero_poses: 
                rospy.logwarn("Goal, but no pose for " + name)
                continue
            elif name not in self.initial_headings:
                rospy.logwarn("Goal, but no initial heading for " + name)
                continue

            cmd = self.cmd_for(self.sphero_poses[name], goal)
            self.cmd_publishers[name].publish(cmd)

    def cmd_for(self, curr_pose, goal_pose, initial_heading=0):
        cmd = HeadingStamped()
        if (pose2d_distance(curr_pose, goal_pose) < GOAL_THRESHOLD):
            pass
        else:
            # Ys need to be flipped because of image coordinate system
            theta_goal = (math.atan2((-1*goal_pose.y) + curr_pose.y, goal_pose.x - curr_pose.x)) # NOTE: afaik we can't reset the sphero's heading through bluetooth
            
            # print(f"goal_to_theta {theta_goal:1.2f} th0 {initial_heading:1.2f}")
            theta_goal = initial_heading - theta_goal


            theta_goal = theta_goal
            current_theta_local = initial_heading - self.pose.theta

            while theta_goal < 0: theta_goal += 2*math.pi
            while theta_goal > 2*math.pi: theta_goal -= 2*math.pi
            while current_theta_local < 0: current_theta_local += 2*math.pi
            while current_theta_local > 2*math.pi: current_theta_local -= 2*math.pi

            diff_theta = abs(theta_goal - current_theta_local)
            # print(f"diff_theta {diff_theta:1.2f}")

            cmd.v = SPEED if diff_theta < (math.pi / 4.) else 0 # Only move forward if we're mostly aligned with the goal
            cmd.theta = rad2deg(theta_goal)
        
        if VERBOSE: rospy.loginfo(f"current {curr_pose.x:1.2f} {curr_pose.y:1.2f} {curr_pose.theta:1.2f} goal {goal_pose.x:1.2f} {goal_pose.y:1.2f} {goal_pose.theta:1.2f} cmd {cmd.v:1.2f} {cmd.theta:1.2f}")
        return cmd

'''
Run a group of commanders that creates one sphero for each name on the topic
'''
def main():
    rospy.init_node("trajectory_follower")
    trajectory_follower_group = TrajectoryFollowerGroup()
    while not (rospy.is_shutdown):
        trajectory_follower_group.update()
        time.sleep(UPDATE_PERIOD)


if __name__ == "__main__":
    try:
    # main_single_commander():
        main()
    except rospy.ROSInterruptException:
        pass