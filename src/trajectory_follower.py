#!/usr/bin/env python3
'''
Node to control an arbitrary number of spheros to their goals
@author james.staley625703@tufts.edu
'''

import traceback
from copy import deepcopy
import time, math, random

from numpy import rad2deg
from IPython import embed

import rospy
from rospy import Subscriber
from std_msgs.msg import Float32
from geometry_msgs.msg import Pose2D, PoseWithCovarianceStamped
from sphero_interface.msg import HeadingStamped, SpheroNames, PositionGoal
from tf.transformations import euler_from_quaternion

import utils

VERBOSE = True

UPDATE_PERIOD = 0.2 # seconds for control loop
SPEED = 30
GOAL_THRESHOLD = 75 # How far we can be from a goal before its considered achieved
TEST_SQUARE_LEN = 200
LOOP_TRAJECTORY = False

'''
Parent class that handles all subscribers and publishers
'''
class TrajectoryFollowerGroup():
    def __init__(self) -> None:
        rospy.Subscriber("/sphero_names", SpheroNames, self.sphero_names_cb)
        
        self.cmd_publishers = dict()
        self.pose_subscribers = dict() # we dont really need to hold on to these but since they're autogenerated lets keep handles to them
        self.goal_subscribers = dict()
        self.initial_heading_subscribers = dict()

        self.initial_headings = dict()
        self.sphero_poses = dict()
        self.goal_poses = dict()

        # self.goal_pub = rospy.Publisher(sphero_id+"/goal", Pose2D, queue_size=1)

    def sphero_names_cb(self, msg: SpheroNames):
        '''
        Callback for the sphero names message.
        '''
        for name in msg.data:
            if name in self.cmd_publishers: 
                pass
            else:
                self.cmd_publishers[name] = rospy.Publisher(name+"/cmd", HeadingStamped, queue_size=1)
                self.pose_subscribers[name] = rospy.Subscriber(name+"/pose", Pose2D, self.pose_callback, callback_args=name)
                self.goal_subscribers[name] = rospy.Subscriber(name+"/goal", PositionGoal, self.goal_callback, callback_args=name)
                self.initial_heading_subscribers[name] = rospy.Subscriber(name+"/initial_heading", HeadingStamped, self.initial_heading_callback, callback_args=name)

    def pose_callback(self, msg, name): self.sphero_poses[name] = msg
    def goal_callback(self, msg, name): self.goal_poses[name] = msg.goal # TODO: this should either have name as a callback arg or use the name in the messages, not both
    def initial_heading_callback(self, msg, name): self.initial_headings[name] = msg.theta

    def update(self):
        for name, goal in self.goal_poses.items():
            if name not in self.sphero_poses: 
                rospy.logwarn("Goal, but no pose for " + name)
                continue
            elif name not in self.initial_headings:
                rospy.logwarn("Goal, but no initial heading for " + name)
                continue

            cmd = self.cmd_for(self.sphero_poses[name], goal, self.initial_headings[name])
            # cmd = self.cmd_for(self.sphero_poses[name], goal)
            self.cmd_publishers[name].publish(cmd)

    def cmd_for(self, curr_pose: Pose2D, goal_pose: Pose2D, initial_heading=0):
        cmd = HeadingStamped()
        distance_to_goal = utils.pose2d_distance(curr_pose, goal_pose)
        if (distance_to_goal < GOAL_THRESHOLD):
            pass
        else:
            # Ys need to be flipped because of image coordinate system
            theta_goal = (math.atan2((-1*goal_pose.y) + curr_pose.y, goal_pose.x - curr_pose.x)) # NOTE: afaik we can't reset the sphero's heading through bluetooth
            theta_goal = utils.cap_0_to_2pi(theta_goal)

            # if VERBOSE: rospy.loginfo(f"target {theta_goal:1.1f} current {curr_pose.theta:1.1f}. distance_to_goal {distance_to_goal:1.2f}")

            diff_theta_world = abs(theta_goal - curr_pose.theta) # dtheta in the world frame
            # diff_theta_local = diff_theta - initial_heading # dtheta in the sphero's frame
            # if VERBOSE: rospy.loginfo(f"dtheta_world {diff_theta:1.1f} from goal. dtheta_local {diff_theta_local:1.1f} from goal. th0 {initial_heading:1.1f}")

            adjusted_theta_goal = theta_goal - initial_heading
            if VERBOSE: rospy.loginfo(f"target {theta_goal:1.1f} adjusted {adjusted_theta_goal:1.1f}. th0 {initial_heading:1.1f} distance_to_goal {distance_to_goal:1.2f}")

            cmd.v = SPEED if abs(diff_theta_world) < (math.pi / 4.) else 0 # Only move forward if we're mostly aligned with the goal
            cmd.theta = rad2deg(utils.cap_0_to_2pi(2*math.pi - adjusted_theta_goal)) # NOTE: The sphero treats clockwise as positive theta and counterclockwise as negative theta, so we're flipping it here so we can use a standard approach
        
        if VERBOSE: rospy.loginfo(f"current x:{curr_pose.x:1.1f} y:{curr_pose.y:1.1f} theta:{curr_pose.theta:1.1f} goal {goal_pose.x:1.1f} {goal_pose.y:1.1f} {goal_pose.theta:1.1f} cmd {cmd.v:1.1f} {cmd.theta:1.1f}")
        return cmd

'''
Run a group of commanders that creates one sphero for each name on the topic
'''
def main():
    rospy.init_node("trajectory_follower")
    trajectory_follower_group = TrajectoryFollowerGroup()
    rospy.loginfo("Looping...")
    while not (rospy.is_shutdown()):
        trajectory_follower_group.update()
        time.sleep(UPDATE_PERIOD)


if __name__ == "__main__":
    try:
    # main_single_commander():
        main()
    except rospy.ROSInterruptException:
        pass